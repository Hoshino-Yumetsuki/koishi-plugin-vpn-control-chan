import { Context, h, Logger, Session } from 'koishi'
import type { Device, VPNPlatform } from './types'
import type Config from '../config'

export class TailscalePlatform implements VPNPlatform {
    name = 'tailscale'

    async generateAuthKey(ctx: Context, config: Config): Promise<string> {
        const { apiUrl, apiKey, tailnet } = config.tailscale

        const response = await ctx.http.post(
            `${apiUrl}/api/v2/tailnet/${tailnet}/keys`,
            {
                keyType: 'client',
                description: 'Generated by VPN Control Chan',
                capabilities: {
                    devices: {
                        create: {
                            reusable: false,
                            ephemeral: false,
                            preauthorized: true
                        }
                    }
                },
                expirySeconds: 7 * 24 * 60 * 60,
                scopes: ['all:read']
            },
            {
                headers: {
                    Authorization: `Bearer ${apiKey}`,
                    'Content-Type': 'application/json'
                }
            }
        )

        if (response && response.key) {
            return response.key
        } else {
            throw new Error('Failed to generate Tailscale Auth Key')
        }
    }

    generateInstallCommand(authKey: string): string {
        return `curl -fsSL https://tailscale.com/install.sh | sh && sudo tailscale up --auth-key=${authKey}`
    }

    async listDevices(ctx: Context, config: Config): Promise<Device[]> {
        const { apiUrl, apiKey, tailnet } = config.tailscale

        const response = await ctx.http.get(
            `${apiUrl}/api/v2/tailnet/${tailnet}/devices`,
            {
                headers: {
                    Authorization: `Bearer ${apiKey}`
                }
            }
        )

        if (response && response.devices) {
            return response.devices.map((device: any) => ({
                id: device.id,
                name: device.name,
                hostname: device.hostname,
                addresses: device.addresses,
                os: device.os,
                clientVersion: device.clientVersion,
                lastSeen: device.lastSeen,
                authorized: device.authorized,
                user: device.user,
                updateAvailable: device.updateAvailable
            }))
        } else {
            throw new Error('Failed to list Tailscale devices')
        }
    }

    async handleNewCommand(
        ctx: Context,
        config: Config,
        session: Session
    ): Promise<void> {
        try {
            if (config.messageBefore) {
                await session.send(config.messageBefore)
            }

            const authKey = await this.generateAuthKey(ctx, config)
            const installCommand = this.generateInstallCommand(authKey)

            await session.send(
                h(
                    'message',
                    h('p', `üîë Tailscale Auth Key (7Â§©ÊúâÊïà):`),
                    h('code', authKey),
                    h('p', `üìã ÂÆâË£ÖÂëΩ‰ª§:`),
                    h('code', installCommand)
                )
            )
        } catch (error) {
            throw error
        }
    }

    async handleListCommand(
        ctx: Context,
        config: Config,
        session: Session
    ): Promise<void> {
        try {
            const devices = await this.listDevices(ctx, config)

            if (devices.length === 0) {
                await session.send('üì± ÂΩìÂâçÊ≤°ÊúâÂ∑≤Ê≥®ÂÜåÁöÑËÆæÂ§á')
                return
            }

            const deviceList = devices.map((device, index) => {
                const lastSeenDate = new Date(device.lastSeen).toLocaleString(
                    'zh-CN'
                )
                const statusIcon = device.authorized ? '‚úÖ' : '‚ùå'
                const updateIcon = device.updateAvailable ? 'üîÑ' : ''

                return h(
                    'p',
                    `${index + 1}. ${statusIcon} ${device.hostname} (${device.os})
üìç ${device.addresses[0]}
üë§ ${device.user}
üïí ${lastSeenDate} ${updateIcon}`
                )
            })

            await session.send(
                h(
                    'message',
                    h('p', `üì± Tailscale ËÆæÂ§áÂàóË°® (${devices.length}Âè∞):`),
                    ...deviceList
                )
            )
        } catch (error) {
            throw error
        }
    }

    registerCommands(ctx: Context, config: Config, logger: Logger): void {
        ctx.command('vcc.tailscale', 'Tailscale ÊéßÂà∂', {
            authority: config.minAuthority
        })
        ctx.command('vcc.tailscale.new', 'ÁîüÊàêÊñ∞ÁöÑ Tailscale Auth Key', {
            authority: config.minAuthority
        })
            .example('vcc.tailscale.new')
            .action(async ({ session }) => {
                try {
                    await this.handleNewCommand(ctx, config, session)

                    logger.info('ÊàêÂäüÁîüÊàê Tailscale Auth Key', {
                        userId: session.userId
                    })
                } catch (error) {
                    logger.error('ÁîüÊàê Tailscale Auth Key Â§±Ë¥•', {
                        error: error.message,
                        userId: session.userId
                    })
                }
            })

        ctx.command('vcc.tailscale.list', 'ÂàóÂá∫ Tailscale ËÆæÂ§á', {
            authority: config.minAuthority
        })
            .example('vcc.tailscale.list')
            .action(async ({ session }) => {
                try {
                    await this.handleListCommand(ctx, config, session)

                    logger.info('ÊàêÂäüÂàóÂá∫ Tailscale ËÆæÂ§á', {
                        userId: session.userId
                    })
                } catch (error) {
                    logger.error('ÂàóÂá∫ Tailscale ËÆæÂ§áÂ§±Ë¥•', {
                        error: error.message,
                        userId: session.userId
                    })
                }
            })
    }
}
