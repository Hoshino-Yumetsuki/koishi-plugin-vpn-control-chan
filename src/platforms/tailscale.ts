import { Context, h, Logger, Session } from 'koishi'
import type { Device, VPNPlatform } from './types'
import type Config from '../config'

export class TailscalePlatform implements VPNPlatform {
    name = 'tailscale'

    async generateAuthKey(ctx: Context, config: Config): Promise<string> {
        const { apiUrl, apiKey, tailnet } = config.tailscale

        try {
            const response = await ctx.http.post(
                `${apiUrl}/api/v2/tailnet/${tailnet}/keys`,
                {
                    capabilities: {
                        devices: {
                            create: {
                                reusable: false,
                                ephemeral: false,
                                preauthorized: true
                            }
                        }
                    },
                    expirySeconds: 604800,
                    description: 'Generated by VPN Control Chan'
                },
                {
                    headers: {
                        Authorization: `Bearer ${apiKey}`,
                        'Content-Type': 'application/json'
                    }
                }
            )

            if (response && response.key) {
                return response.key
            } else {
                throw new Error(`API å“åº”å¼‚å¸¸: ${JSON.stringify(response)}`)
            }
        } catch (error) {
            if (error.response) {
                const status = error.response.status
                const data = error.response.data
                throw new Error(
                    `Tailscale API é”™è¯¯ (${status}): ${JSON.stringify(data)}`
                )
            }
            throw new Error(`ç½‘ç»œè¯·æ±‚å¤±è´¥: ${error.message}`)
        }
    }

    generateInstallCommand(authKey: string): string {
        return `curl -fsSL https://tailscale.com/install.sh | sh && sudo tailscale up --auth-key=${authKey}`
    }

    // å¤„ç†è®¾å¤‡åç§°ï¼Œç§»é™¤åŸŸååç¼€
    private formatDeviceName(name: string): string {
        if (!name) return ''

        // ä½¿ç”¨ç¬¬ä¸€ä¸ªç‚¹å·åˆ†å‰²è®¾å¤‡åç§°ï¼Œåªä¿ç•™å‰åŠéƒ¨åˆ†
        const parts = name.split('.')
        return parts[0]
    }

    async listDevices(ctx: Context, config: Config): Promise<Device[]> {
        const { apiUrl, apiKey, tailnet } = config.tailscale

        const response = await ctx.http.get(
            `${apiUrl}/api/v2/tailnet/${tailnet}/devices`,
            {
                headers: {
                    Authorization: `Bearer ${apiKey}`
                }
            }
        )

        if (response && response.devices) {
            return response.devices.map((device: any) => ({
                id: device.id,
                name: device.name,
                hostname: device.hostname,
                addresses: device.addresses,
                os: device.os,
                clientVersion: device.clientVersion,
                lastSeen: device.lastSeen,
                authorized: device.authorized,
                user: device.user,
                updateAvailable: device.updateAvailable
            }))
        } else {
            throw new Error('Failed to list Tailscale devices')
        }
    }

    async handleNewCommand(
        ctx: Context,
        config: Config,
        session: Session
    ): Promise<void> {
        if (config.messageBefore) {
            await session.send(config.messageBefore)
        }

        const authKey = await this.generateAuthKey(ctx, config)
        const installCommand = this.generateInstallCommand(authKey)

        await session.send(
            h(
                'message',
                h('p', `å‘€ï¼Auth Key åœ¨è¿™é‡Œå•¦ï½ (7å¤©å†…æœ‰æ•ˆå“¦):`),
                h('code', authKey),
                h('p', `ä¸€é”®å®‰è£…å‘½ä»¤:`),
                h('code', installCommand),
                h(
                    'p',
                    `æ¸©é¦¨æç¤º: æŠŠä¸Šé¢çš„å‘½ä»¤å¤åˆ¶åˆ°ç›®æ ‡è®¾å¤‡æ‰§è¡Œï¼Œå°±èƒ½è‡ªåŠ¨å®‰è£…å¹¶è¿æ¥ Tailscale å•¦ï½`
                )
            )
        )
    }

    async handleListCommand(
        ctx: Context,
        config: Config,
        session: Session,
        page: number = 1
    ): Promise<void> {
        const devices = await this.listDevices(ctx, config)

        if (devices.length === 0) {
            await session.send('å’¦ï¼Ÿå¥½åƒè¿˜æ²¡æœ‰è®¾å¤‡è¿æ¥å‘¢ï½å¿«å»æ·»åŠ ä¸€å°è®¾å¤‡å§ï¼')
            return
        }

        const pageSize = 10
        const totalPages = Math.ceil(devices.length / pageSize)
        const startIndex = (page - 1) * pageSize
        const endIndex = startIndex + pageSize
        const paginatedDevices = devices.slice(startIndex, endIndex)

        if (page > totalPages) {
            await session.send(
                `å“å‘€ï¼Œé¡µæ•°è¶…å‡ºèŒƒå›´å•¦ï½æ€»å…±åªæœ‰ ${totalPages} é¡µå“¦`
            )
            return
        }

        if (paginatedDevices.length === 0) {
            await session.send(`å—¯...ç¬¬ ${page} é¡µå¥½åƒæ²¡æœ‰è®¾å¤‡å‘¢`)
            return
        }

        const deviceList = paginatedDevices.map((device, index) => {
            const lastSeenDate = new Date(device.lastSeen).toLocaleString(
                'zh-CN'
            )
            const statusIcon = device.authorized ? 'âœ…' : 'âŒ'
            const updateIcon = device.updateAvailable ? 'ğŸ”„' : ''

            return h(
                'p',
                `${startIndex + index + 1}. ${statusIcon} ${this.formatDeviceName(device.name)} (${device.os})
 ${device.addresses[0]}
 ${device.user}
 ${lastSeenDate} ${updateIcon}`
            )
        })

        await session.send(
            h(
                'message',
                h(
                    'p',
                    `æ‰€æœ‰çš„è®¾å¤‡éƒ½åœ¨è¿™é‡Œå•¦ï½ (å…± ${devices.length} å°ï¼Œç¬¬ ${page} é¡µ/å…± ${totalPages} é¡µ):`
                ),
                ...deviceList
            )
        )
    }

    private calculateSimilarity(str1: string, str2: string): number {
        const len1 = str1.length
        const len2 = str2.length
        const matrix = Array(len1 + 1)
            .fill(null)
            .map(() => Array(len2 + 1).fill(null))

        for (let i = 0; i <= len1; i++) matrix[i][0] = i
        for (let j = 0; j <= len2; j++) matrix[0][j] = j

        for (let i = 1; i <= len1; i++) {
            for (let j = 1; j <= len2; j++) {
                if (str1[i - 1] === str2[j - 1]) {
                    matrix[i][j] = matrix[i - 1][j - 1]
                } else {
                    matrix[i][j] = Math.min(
                        matrix[i - 1][j] + 1,
                        matrix[i][j - 1] + 1,
                        matrix[i - 1][j - 1] + 1
                    )
                }
            }
        }

        const maxLen = Math.max(len1, len2)
        return maxLen === 0 ? 1 : (maxLen - matrix[len1][len2]) / maxLen
    }

    private searchDevices(devices: Device[], query: string): Device[] {
        const normalizedQuery = query.toLowerCase()
        const results: { device: Device; score: number }[] = []

        devices.forEach((device) => {
            let maxScore = 0
            // æœç´¢æ—¶åŒæ ·éœ€è¦å»é™¤è®¾å¤‡åç§°çš„åŸŸååç¼€
            const searchFields = [
                this.formatDeviceName(device.name),
                device.user,
                device.os,
                device.addresses[0] || '',
                device.clientVersion || ''
            ]

            searchFields.forEach((field) => {
                const normalizedField = field.toLowerCase()

                if (normalizedField.includes(normalizedQuery)) {
                    maxScore = Math.max(maxScore, 1.0)
                    return
                }

                const similarity = this.calculateSimilarity(
                    normalizedQuery,
                    normalizedField
                )
                if (similarity >= 0.7) {
                    maxScore = Math.max(maxScore, similarity)
                }
            })

            if (maxScore > 0) {
                results.push({ device, score: maxScore })
            }
        })

        return results
            .sort((a, b) => b.score - a.score)
            .map((result) => result.device)
    }

    async deleteDevice(
        ctx: Context,
        config: Config,
        deviceId: string
    ): Promise<boolean> {
        const { apiUrl, apiKey } = config.tailscale

        try {
            await ctx.http.delete(`${apiUrl}/api/v2/device/${deviceId}`, {
                headers: {
                    Authorization: `Bearer ${apiKey}`,
                    'Content-Type': 'application/json'
                }
            })
            return true
        } catch (error) {
            if (error.response) {
                const status = error.response.status
                const data = error.response.data
                throw new Error(
                    `Tailscale API é”™è¯¯ (${status}): ${JSON.stringify(data)}`
                )
            }
            throw new Error(`ç½‘ç»œè¯·æ±‚å¤±è´¥: ${error.message}`)
        }
    }

    async handleDeleteCommand(
        ctx: Context,
        config: Config,
        session: Session,
        deviceId: string
    ): Promise<void> {
        if (!deviceId || deviceId.trim().length === 0) {
            await session.send('è¯·æä¾›è¦åˆ é™¤çš„è®¾å¤‡IDå“¦ï½')
            return
        }

        try {
            const devices = await this.listDevices(ctx, config)

            let device = devices.find(
                (d) =>
                    d.id === deviceId ||
                    d.name === deviceId ||
                    d.hostname === deviceId
            )

            if (!device) {
                device = devices.find((d) => {
                    const formattedDeviceName = this.formatDeviceName(d.name)
                    return formattedDeviceName === deviceId
                })
            }

            if (!device) {
                await session.send(
                    `æ‰¾ä¸åˆ°IDä¸º "${deviceId}" çš„è®¾å¤‡å‘¢ï¼Œè¯·ç¡®è®¤IDæ˜¯å¦æ­£ç¡®ï½`
                )
                return
            }

            await session.send(
                h(
                    'message',
                    h('p', `ä½ ç¡®å®šè¦åˆ é™¤è¿™å°è®¾å¤‡å—ï¼Ÿ`),
                    h('p', `è®¾å¤‡åç§°: ${this.formatDeviceName(device.name)}`),
                    h('p', `ç³»ç»Ÿç±»å‹: ${device.os}`),
                    h('p', `æ‰€å±ç”¨æˆ·: ${device.user}`),
                    h('p', `è¯·è¾“å…¥ y æˆ– yes ç¡®è®¤åˆ é™¤ï¼Œè¾“å…¥å…¶ä»–å†…å®¹å–æ¶ˆ:`)
                )
            )

            const result = await session.prompt(15000)

            if (result === null) {
                await session.send('å›å¤è¶…æ—¶ï¼Œå·²è‡ªåŠ¨å–æ¶ˆåˆ é™¤æ“ä½œï½')
                return
            }

            const confirmation = result.toLowerCase()

            if (confirmation === 'y' || confirmation === 'yes') {
                await this.deleteDevice(ctx, config, device.id)
                await session.send(
                    `è®¾å¤‡ "${this.formatDeviceName(device.name)}" å·²æˆåŠŸåˆ é™¤ï½`
                )
            } else {
                await session.send('å·²å–æ¶ˆåˆ é™¤æ“ä½œï½')
            }
        } catch (error) {
            throw new Error(`åˆ é™¤è®¾å¤‡å¤±è´¥: ${error.message}`)
        }
    }

    async handleSearchCommand(
        ctx: Context,
        config: Config,
        session: Session,
        query: string
    ): Promise<void> {
        if (!query || query.trim().length === 0) {
            await session.send('è¯·è¾“å…¥è¦æœç´¢çš„å†…å®¹å“¦ï½')
            return
        }

        const devices = await this.listDevices(ctx, config)

        if (devices.length === 0) {
            await session.send('å’¦ï¼Ÿå¥½åƒè¿˜æ²¡æœ‰è®¾å¤‡è¿æ¥å‘¢ï½å¿«å»æ·»åŠ ä¸€å°è®¾å¤‡å§ï¼')
            return
        }

        const searchResults = this.searchDevices(devices, query.trim())

        if (searchResults.length === 0) {
            await session.send(
                `æ²¡æœ‰æ‰¾åˆ°åŒ…å« "${query}" çš„è®¾å¤‡å‘¢ï½æ¢ä¸ªå…³é”®è¯è¯•è¯•å§`
            )
            return
        }

        const deviceList = searchResults.map((device, index) => {
            const lastSeenDate = new Date(device.lastSeen).toLocaleString(
                'zh-CN'
            )
            const statusIcon = device.authorized ? 'âœ…' : 'âŒ'
            const updateIcon = device.updateAvailable ? 'ğŸ”„' : ''

            return h(
                'p',
                `${index + 1}. ${statusIcon} ${this.formatDeviceName(device.name)} (${device.os})
 ${device.addresses[0]}
 ${device.user}
 ${lastSeenDate} ${updateIcon}`
            )
        })

        await session.send(
            h(
                'message',
                h('p', `æ‰¾åˆ° ${searchResults.length} å°åŒ¹é…çš„è®¾å¤‡å“¦ï½`),
                ...deviceList
            )
        )
    }

    registerCommands(ctx: Context, config: Config, logger: Logger): void {
        ctx.command('vcc.tailscale', 'Tailscale æ§åˆ¶', {
            authority: config.minAuthority
        })
        ctx.command('vcc.tailscale.new', 'ç”Ÿæˆæ–°çš„ Tailscale Auth Key', {
            authority: config.minAuthority
        })
            .example('vcc.tailscale.new')
            .action(async ({ session }) => {
                try {
                    await this.handleNewCommand(ctx, config, session)

                    logger.info('æˆåŠŸç”Ÿæˆ Tailscale Auth Key', {
                        userId: session.userId
                    })
                } catch (error) {
                    logger.error('ç”Ÿæˆ Tailscale Auth Key å¤±è´¥', {
                        error: error.message,
                        userId: session.userId
                    })
                    await session.send(
                        `å“å‘€ï¼ŒAuth Key ç”Ÿæˆå¤±è´¥äº†å‘¢ï½ ${error.message}`
                    )
                }
            })

        ctx.command('vcc.tailscale.list', 'åˆ—å‡º Tailscale è®¾å¤‡', {
            authority: config.minAuthority
        })
            .option('page', '-p <page:number>')
            .example('vcc.tailscale.list')
            .example('vcc.tailscale.list -p 2')
            .action(async ({ session, options }) => {
                try {
                    const page = Number(options.page) || 1
                    await this.handleListCommand(ctx, config, session, page)

                    logger.info('æˆåŠŸåˆ—å‡º Tailscale è®¾å¤‡', {
                        userId: session.userId,
                        page
                    })
                } catch (error) {
                    logger.error('åˆ—å‡º Tailscale è®¾å¤‡å¤±è´¥', {
                        error: error.message,
                        userId: session.userId
                    })
                    await session.send(
                        `å“å‘€ï¼Œåˆ—å‡ºè®¾å¤‡å¤±è´¥äº†å‘¢ï½ ${error.message}`
                    )
                }
            })

        ctx.command(
            'vcc.tailscale.search <query:string>',
            'æœç´¢ Tailscale è®¾å¤‡',
            {
                authority: config.minAuthority
            }
        )
            .example('vcc.tailscale.search myserver')
            .example('vcc.tailscale.search windows')
            .example('vcc.tailscale.search 192.168')
            .action(async ({ session }, query) => {
                try {
                    await this.handleSearchCommand(ctx, config, session, query)

                    logger.info('æˆåŠŸæœç´¢ Tailscale è®¾å¤‡', {
                        userId: session.userId,
                        query
                    })
                } catch (error) {
                    logger.error('æœç´¢ Tailscale è®¾å¤‡å¤±è´¥', {
                        error: error.message,
                        userId: session.userId
                    })
                    await session.send(
                        `å“å‘€ï¼Œæœç´¢è®¾å¤‡å¤±è´¥äº†å‘¢ï½ ${error.message}`
                    )
                }
            })

        ctx.command(
            'vcc.tailscale.delete <deviceId:string>',
            'åˆ é™¤ Tailscale è®¾å¤‡',
            {
                authority: config.minAuthority
            }
        )
            .example('vcc.tailscale.delete device-id')
            .example('vcc.tailscale.delete hostname')
            .action(async ({ session }, deviceId) => {
                try {
                    await this.handleDeleteCommand(
                        ctx,
                        config,
                        session,
                        deviceId
                    )

                    logger.info('æˆåŠŸåˆ é™¤ Tailscale è®¾å¤‡', {
                        userId: session.userId,
                        deviceId
                    })
                } catch (error) {
                    logger.error('åˆ é™¤ Tailscale è®¾å¤‡å¤±è´¥', {
                        error: error.message,
                        userId: session.userId
                    })
                    await session.send(
                        `å“å‘€ï¼Œåˆ é™¤è®¾å¤‡å¤±è´¥äº†å‘¢ï½ ${error.message}`
                    )
                }
            })
    }
}
